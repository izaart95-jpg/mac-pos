name: RustDesk Screenshot macOS

on:
  workflow_dispatch:

jobs:
  rustdesk-screenshot:
    runs-on: macos-latest
    timeout-minutes: 360  # 24 hours

    steps:
      - name: Download RustDesk
        run: |
          rustdeskUrl="https://github.com/rustdesk/rustdesk/releases/download/1.4.4/rustdesk-1.4.4-x86_64.dmg"
          rustdeskPath="$HOME/Downloads/rustdesk.dmg"
          curl -L -o "$rustdeskPath" "$rustdeskUrl"
          echo "RUSTDESK_DMG=$rustdeskPath" >> $GITHUB_ENV
          echo "RUSTDESK_APP=/Applications/RustDesk.app" >> $GITHUB_ENV

      - name: Mount DMG and install RustDesk
        run: |
          # Mount the DMG
          hdiutil attach "$RUSTDESK_DMG" -mountpoint /Volumes/RustDesk -nobrowse
          
          # Copy RustDesk to Applications
          sudo cp -R "/Volumes/RustDesk/RustDesk.app" /Applications/
          
          # Unmount the DMG
          hdiutil detach /Volumes/RustDesk
          
          # Verify installation
          if [ -d "/Applications/RustDesk.app" ]; then
            echo "RustDesk installed successfully"
          else
            echo "Failed to install RustDesk"
            exit 1
          fi

      - name: Create working directory
        run: |
          workDir="$GITHUB_WORKSPACE/screenshots"
          mkdir -p "$workDir"
          echo "WORK_DIR=$workDir" >> $GITHUB_ENV

      - name: Prepare for screen recording
        run: |
          # First, we need to enable assistive devices and accessibility API
          echo "Enabling accessibility features..."
          
          # Enable assistive devices (this requires password, but we try anyway)
          echo "a" | sudo accessibility_enable || true
          
          # Grant accessibility permissions to Terminal (or the runner)
          sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" "INSERT OR REPLACE INTO access VALUES('kTCCServiceAccessibility','com.apple.Terminal',0,1,1,NULL,NULL,NULL,'UNUSED',NULL,0,UNIXEPOCH());" 2>/dev/null || true
          
          # Also try for bash/zsh
          sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" "INSERT OR REPLACE INTO access VALUES('kTCCServiceAccessibility','/bin/bash',0,1,1,NULL,NULL,NULL,'UNUSED',NULL,0,UNIXEPOCH());" 2>/dev/null || true
          
          # Grant screen recording permissions to Terminal
          sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" "INSERT OR REPLACE INTO access VALUES('kTCCServiceScreenRecording','com.apple.Terminal',0,1,1,NULL,NULL,NULL,'UNUSED',NULL,0,UNIXEPOCH());" 2>/dev/null || true
          
          # Grant screen recording to bash
          sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" "INSERT OR REPLACE INTO access VALUES('kTCCServiceScreenRecording','/bin/bash',0,1,1,NULL,NULL,NULL,'UNUSED',NULL,0,UNIXEPOCH());" 2>/dev/null || true
          
          # Grant screen recording to zsh
          sudo sqlite3 "/Library/Application Support/com.apple.TCC/TCC.db" "INSERT OR REPLACE INTO access VALUES('kTCCServiceScreenRecording','/bin/zsh',0,1,1,NULL,NULL,NULL,'UNUSED',NULL,0,UNIXEPOCH());" 2>/dev/null || true
          
          # Kill TCC daemon to reload permissions
          sudo pkill -9 TCC 2>/dev/null || true
          sleep 2

      - name: Accept security prompt using AppleScript
        run: |
          # This AppleScript will handle the security prompt
          cat > /tmp/accept_prompt.applescript << 'EOF'
          tell application "System Events"
            # Wait for the security prompt to appear
            repeat with i from 1 to 60
              try
                # Look for the "bash" security prompt
                if exists (process "SecurityAgent") then
                  # Look for the window with "bash" in the title
                  repeat with w in windows of process "SecurityAgent"
                    try
                      if name of w contains "bash" or name of w contains "Screen Recording" then
                        # Click the "Allow" button
                        click button "Allow" of w
                        log "Clicked Allow button"
                        return true
                      end if
                    end try
                  end repeat
                  
                  # Alternative: look for any dialog with allow button
                  repeat with w in windows of process "SecurityAgent"
                    try
                      if exists (button "Allow" of w) then
                        click button "Allow" of w
                        log "Clicked Allow button on generic dialog"
                        return true
                      end if
                    end try
                  end repeat
                end if
              end try
              delay 1
            end repeat
            return false
          end tell
          EOF
          
          # Run the AppleScript in the background
          osascript /tmp/accept_prompt.applescript &

      - name: Start RustDesk and handle prompt
        run: |
          # Start RustDesk and give it time to trigger the prompt
          open -a /Applications/RustDesk.app
          echo "RustDesk started, waiting for security prompt..."
          
          # Wait for the prompt to appear and be handled
          sleep 30
          
          # Check if RustDesk is running
          if pgrep -f "RustDesk" > /dev/null; then
            echo "RustDesk is running"
          else
            echo "RustDesk may have closed, trying to restart"
            open -a /Applications/RustDesk.app
            sleep 15
          fi

      - name: Alternative approach using launchd service
        if: always()
        run: |
          # Create a launch agent to auto-accept the prompt
          cat > /tmp/com.rustdesk.allow.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>Label</key>
              <string>com.rustdesk.allow</string>
              <key>ProgramArguments</key>
              <array>
                  <string>osascript</string>
                  <string>-e</string>
                  <string>
                  tell application "System Events"
                    repeat
                      try
                        if exists (process "SecurityAgent") then
                          tell process "SecurityAgent"
                            if exists (button "Allow" of window 1) then
                              click button "Allow" of window 1
                              exit repeat
                            end if
                          end tell
                        end if
                      end try
                      delay 0.5
                    end repeat
                  end tell
                  </string>
              </array>
              <key>RunAtLoad</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          # Load the launch agent
          sudo cp /tmp/com.rustdesk.allow.plist /Library/LaunchAgents/
          sudo launchctl load /Library/LaunchAgents/com.rustdesk.allow.plist 2>/dev/null || true

      - name: Take screenshots using different methods
        run: |
          cd "$WORK_DIR"
          
          # Method 1: Try with screencapture
          echo "Attempting screenshot with screencapture..."
          screenshotPath="$WORK_DIR/screenshot_1.png"
          
          # Use a longer delay to ensure permissions are granted
          sleep 10
          
          # Take screenshot - add retry logic
          for attempt in {1..5}; do
            echo "Attempt $attempt to capture screenshot..."
            if screencapture -x "$screenshotPath" 2>/dev/null; then
              if [ -f "$screenshotPath" ] && [ -s "$screenshotPath" ]; then
                echo "Screenshot captured successfully on attempt $attempt"
                ls -lh "$screenshotPath"
                break
              fi
            fi
            sleep 5
          done

      - name: Try Python-based screenshot
        if: always()
        run: |
          cd "$WORK_DIR"
          
          python3 -c "
          import time
          import subprocess
          import os
          import Quartz
          import LaunchServices
          from Foundation import NSURL
          from AppKit import NSScreen, NSBitmapImageRep, NSJPEGFileType
          
          print('Attempting to take screenshot using Python...')
          
          # Method 1: Try using subprocess first
          for i in range(3):
              filename = f'$WORK_DIR/python_screenshot_{i}.png'
              try:
                  result = subprocess.run(['screencapture', '-x', filename], 
                                         capture_output=True, timeout=10)
                  if os.path.exists(filename) and os.path.getsize(filename) > 0:
                      print(f'Success with screencapture: {filename}')
                      break
              except Exception as e:
                  print(f'Attempt {i} failed: {e}')
                  time.sleep(2)
          
          # Method 2: Try using Quartz directly (macOS native API)
          try:
              # Get the main display
              main_display = Quartz.CGMainDisplayID()
              
              # Create screenshot
              image = Quartz.CGDisplayCreateImage(main_display)
              if image:
                  # Convert to NSImage and save
                  width = Quartz.CGImageGetWidth(image)
                  height = Quartz.CGImageGetHeight(image)
                  
                  # Create bitmap representation
                  bitmap = NSBitmapImageRep.alloc().initWithBitmapDataPlanes_pixelsWide_pixelsHigh_bitsPerSample_samplesPerPixel_hasAlpha_isPlanar_colorSpaceName_bitmapFormat_bytesPerRow_bitsPerPixel_(
                      None, width, height, 8, 4, True, False, 
                      NSDeviceRGBColorSpace, 0, 0, 0
                  )
                  
                  # Create context and draw
                  context = bitmap.graphicsPort()
                  Quartz.CGContextDrawImage(context, Quartz.CGRectMake(0, 0, width, height), image)
                  
                  # Save to file
                  output_path = '$WORK_DIR/quartz_screenshot.png'
                  bitmap_data = bitmap.representationUsingType_properties_(NSJPEGFileType, {})
                  if bitmap_data:
                      bitmap_data.writeToFile_atomically_(output_path, True)
                      print(f'Screenshot saved via Quartz: {output_path}')
          except Exception as e:
              print(f'Quartz method failed: {e}')
          "

      - name: Verify screenshots were captured
        run: |
          echo "Checking for screenshots in: $WORK_DIR"
          ls -la "$WORK_DIR"
          
          # Check file sizes
          for file in "$WORK_DIR"/*.png "$WORK_DIR"/*.jpg; do
            if [ -f "$file" ]; then
              size=$(ls -lh "$file" | awk '{print $5}')
              echo "Found: $file (Size: $size)"
            fi
          done
          
          # Count valid screenshots
          valid_count=$(find "$WORK_DIR" -name "*.png" -type f -size +1k 2>/dev/null | wc -l)
          echo "Valid screenshots: $valid_count"
          
          if [ "$valid_count" -eq 0 ]; then
            echo "Warning: No screenshots captured. This is likely due to:"
            echo "1. macOS security restrictions (Screen Recording permission)"
            echo "2. The security prompt was not auto-accepted"
            echo "3. No active display in CI environment"
            
            # Create a dummy file to show workflow ran
            echo "Screenshot capture failed due to macOS permissions" > "$WORK_DIR/error.txt"
            echo "In CI environments, screen recording typically requires:" >> "$WORK_DIR/error.txt"
            echo "1. Physical user interaction to accept the prompt" >> "$WORK_DIR/error.txt"
            echo "2. A logged-in user session with a display" >> "$WORK_DIR/error.txt"
          fi

      - name: Upload screenshots as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: rustdesk-screenshots-macos
          path: |
            ${{ env.WORK_DIR }}/*.png
            ${{ env.WORK_DIR }}/*.jpg
            ${{ env.WORK_DIR }}/error.txt
          retention-days: 1

      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up..."
          
          # Remove launch agent
          sudo launchctl unload /Library/LaunchAgents/com.rustdesk.allow.plist 2>/dev/null || true
          sudo rm -f /Library/LaunchAgents/com.rustdesk.allow.plist 2>/dev/null || true
          
          # Quit RustDesk
          pkill -f "RustDesk" 2>/dev/null || true
          pkill -f "rustdesk" 2>/dev/null || true
          
          # Remove DMG
          rm -f "$HOME/Downloads/rustdesk.dmg" 2>/dev/null || true
          
          echo "Cleanup complete"
